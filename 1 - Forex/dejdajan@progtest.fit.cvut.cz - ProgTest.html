<!--?xml version="1.0" encoding="utf-8" ?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml-transitional.dtd">
<html><head>
  <title>dejdajan@progtest.fit.cvut.cz - ProgTest</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <link href="dejdajan@progtest.fit.cvut.cz%20-%20ProgTest_soubory/css.css" rel="stylesheet" type="text/css">
  <script src="dejdajan@progtest.fit.cvut.cz%20-%20ProgTest_soubory/shared.js" language="JavaScript" type="text/javascript"></script>
  
 </head>
 <body bgcolor="#828273" text="#000000">
  <table border="0" cellpadding="0" cellspacing="0" width="100%">
   <tbody><tr height="25">
    <td align="left" bgcolor="#00ff00"><span class="navLink"><a class="navLink" href="https://progtest.fit.cvut.cz/index.php?X=Main">ProgTest</a>&nbsp;&nbsp;►&nbsp;&nbsp;<a class="navLink" href="https://progtest.fit.cvut.cz/index.php?X=Course&amp;Cou=170">BI-OSY (15/16 LS)</a>&nbsp;&nbsp;►&nbsp;&nbsp;<a class="navLink" href="https://progtest.fit.cvut.cz/index.php?X=TaskGrp&amp;Cou=170&amp;Tgr=1062">Úloha #1</a>&nbsp;&nbsp;►&nbsp;&nbsp;<b>Forex</b></span></td>
    <td align="right" bgcolor="#00ff00"><a class="navLink" href="https://progtest.fit.cvut.cz/index.php?X=Logout">Logout</a></td>
   </tr>
  </tbody></table>
<br>




 <br>
 <br>
   <center>
   <div class="topLayout">
    <div class="outBox">
     <table class="header" cellpadding="0" cellspacing="0" width="100%">
      <tbody><tr>
       <td class="header"><b>Forex</b></td>
      </tr>
     </tbody></table>
    </div>
   </div>
  </center>
 <form name="form1" method="post" action="?X=TaskU&amp;Cou=170&amp;Tgr=1062&amp;Tsk=1303" enctype="multipart/form-data">
  <center>
    <div class="topLayout">
     <div class="outBox">
      <table id="maintable" border="0" cellpadding="2" cellspacing="0" width="100%">
       <colgroup><col width="200">
       <col>
       <col width="130">

       </colgroup><tbody><tr>
        <td class="ltCell" align="left"><b>Termín odevzdání:</b></td>
        <td class="tCell" align="left"><b>10.04.2016 23:59:59</b></td>
        <td class="rtCell" id="countdown" align="right">2432377.753 sec</td>
       </tr>

       <tr>
        <td class="lCell" align="left"><b>Hodnocení:</b></td>
        <td class="rCell" colspan="2" align="left"><b>0.0000</b></td>
       </tr>
       <tr>
        <td class="lCell" align="left"><b>Max. hodnocení:</b></td>
        <td class="rCell" colspan="2" align="left"><b>30.0000</b> (bez bonusů)</td>
       </tr>
       <tr>
        <td class="lCell" align="left"><b>Odevzdaná řešení:</b></td>
        <td class="rCell" colspan="2" align="left">0 /  60</td>
       </tr>

       <tr>
        <td class="lbCell" align="left"><b>Nápovědy:</b></td>
        <td class="rbCell" colspan="2" align="left">0 / 0</td>
       </tr>

       <tr>
        <td class="lrtbCell" colspan="3" align="left"><p>Úkolem je realizovat třídu, která bude umožňovat rychle řešit problémy 
v oblasti bankovnictví.</p>

<p>Předpokládáme bankovní operace na finančních trzích. Banka sestavuje 
svůj kurzovní lístek, ve kterém pro vybrané dvojice měn vyplní směnný kurz.
Banka má absolutní volnost, které dvojice měn a za jaký kurz bude směňovat. 
Tedy banka může nabízet např. směnu USD -&gt; EUR, ale nemusí nabízet směnu 
EUR -&gt; USD.</p>

<p>Směnné kurzy vždy zpracováváme na 4 desetinná místa (pips). Takto 
zaokrouhleným kurzem jsou přepočítávané všechny směny, které banka provádí 
pro své klienty. Uvnitř banky se ale používá kurz nezaokrouhlený, zaokrouhluje 
se pouze 1x po provedení všech směn uvnitř banky. Pokud tedy banka má kurzovní lístek např.:
</p><pre>CZK -&gt; USD: 0.0398
USD -&gt; EUR: 0.9259
EUR -&gt; GBP: 0.7728
</pre>

pak může klient požádat o převod CZK -&gt; USD -&gt; EUR -&gt; GBP. Banka použije zveřejněné kurzy a 
jejich vynásobením dostane 0.02847831.., který pro klienta upraví na 4 desetinná místa 
(další řády odsekne, zaokrouhlí směrem dolů) na kurz 0.0284. Předpokládáme, že banka 
nevyžaduje další poplatky za směnu (poplatky za směnu jsou zahrnuty v kurzech).<p></p>

<p>Při zveřejnění kurzu si banka musí dát pozor, aby se postupnými konverzemi nedošlo 
k situaci, kde by se peníze daly "vyrobit" směnou v kruhu. Pokud by v uvedeném příkladu 
banka nabízela i směnu GBP -&gt; CZK: 35.1263, pak by se konverzí CZK -&gt; USD -&gt; 
EUR -&gt; GBP -&gt; CZK došlo ke kurzu 1.0003378... (pro zákazníka 1.0003), tedy na vložené koruně 
by šlo vydělat 0.03 haléře (což pro velký objem vložených peněz a velké množství konverzí 
může být mnoho peněz). Takovému jevu se říká arbitrage. Problémem je zjistit, zda daný kurzovní 
lístek obsahuje arbitrage, případně jakými směnami lze k arbitrage dojít.</p>

<p>Zcela opačný problém řeší klienti bank. Ti mají k dispozici kurzovní lístky jednotlivých 
bank a potřebují převést své peníze z jedné měny do druhé. Vyberou si banku a té předají seznam
požadovaných konverzí. Banka provede požadované konverze (viz pravidla výše) a podle vypočteného 
kurzu proplatí peníze. Banka například může nabízet následující kurzy:
</p><pre>CZK -&gt; USD: 0.0398
USD -&gt; EUR: 0.9259
EUR -&gt; GBP: 0.7728
CZK -&gt; GBP: 0.0280
</pre>
Pokud bychom chtěli převést CZK na GBP, mohli bychom použít přímo kurz 0.0280 nebo použít 
konverzi CZK -&gt; USD -&gt; EUR -&gt; GBP a dosáhnout lepšího kurzu 0.0284.<p></p>

<p>Vaším úkolem je realizovat třídu <tt>CConsultant</tt>, která dokáže takové problémy řešit. 
Oba uvedené problémy jsou výpočetně náročnější a oba problémy je potřeba řešit rychle (kurzy 
se mění). Proto bude využito vláken k rozdělení výpočetní zátěže na více CPU a asynchronního 
modelu výpočtu.</p>

<p>Třída <tt>CConsultant</tt> má modelovat finančního poradce, který přebírá problémy k řešení, 
řeší je a po vyřešení informuje o dokončení výpočtu. Pro načítání problémů si vytvořte dvě pomocná 
vlákna. Vlákna budou volat zadané funkce, jedno vlákno bude volat funkci pro doručování 
problémů typu arbitrage, druhé pro doručování problémů hledání výhodného kurzu. Zadaný problém 
má podobu instance třídy <tt>CArbitrage</tt> nebo třídy <tt>CExchange</tt> (podle typu úlohy). 
Pomocná vlákna předají získané instance problémů vláknům pracovním. Vlákna, která přebírají 
zadávané problémy, nejsou určena k tomu, aby počítala řešení, jejich úkolem je pouze předání 
problémů dále.</p>

<p>Pracovních vláken vytvoříte více (podle parametrů při inicializaci). Pracovní vlákna vyřeší 
zadanou instanci problémů a podle výsledků vyplní příslušné složky instance <tt>CArbitrage</tt> 
/ <tt>CExchange</tt>. Po vyplnění informují zadavatele o dokončení výpočtu dané instance problému tím, že 
zavolají notifikační funkci s identifikací vyřešené instance problému (identifikátor je součástí 
předané instance <tt>CArbitrage</tt> / <tt>CExchange</tt>).</p>

<p>Rozhraním vaší implementace bude třída <tt>CConsultant</tt>. V této třídě musí být k dispozici 
metody podle popisu níže (mohou existovat i další privátní metody potřebné pro Vaší implementaci):</p>

<dl>
 <dt><tt>konstruktor(arbFn,xchgFn,complFn)</tt></dt><dd>inicializuje instanci. Má parametry 
  <ul>
   <li><tt>arbFn</tt> - ukazatel na funkci, která po zavolání dodá další instanci problému 
     arbitrage k vyřešení. Vaše implementace bude tuto funkci volat opakovaně, každé zavolání 
     dodá další instanci třídy <tt>CArbitrage</tt> (popis níže). Zadávání problémů <tt>CArbitrage</tt>
     skončí v okamžiku, kdy volání této funkce vrátí hodnotu <tt>NULL</tt>.</li>

   <li><tt>xchgFn</tt> - ukazatel na funkci, která po zavolání dodá další instanci problému 
     nalezení nejvýhodnějšího způsobu směny peněz. Vaše implementace bude tuto funkci volat 
     opakovaně, každé zavolání dodá další instanci třídy <tt>CExchange</tt> (popis níže). Zadávání 
     problémů <tt>CExchange</tt> skončí v okamžiku, kdy volání této funkce vrátí hodnotu <tt>NULL</tt>.</li>

   <li><tt>complFn</tt> - ukazatel na funkci, kterou Vaše implementace zavolá po vyřešení každého 
    jednoho zadaného problému (<tt>CArbitrage / CExchange</tt>). Funkci předáte v parametru identifikátor 
    vyřešeného problému (tento identifikátor dostanete jako členskou proměnnou v <tt>CArbitrage/CExchange</tt>).</li></ul></dd>

 <dt><tt>Execute (thr)</tt></dt><dd>Metoda spustí vlastní výpočet. V této metodě vytvoříte 
    potřebná pracovní vlákna pro výpočty a vlákna, která budou načítat vstupy. Pracovních vláken 
    vytvořte celkem <tt>thr</tt> podle hodnoty parametru. Metoda <tt>Execute</tt> skončí v okamžiku, kdy 
    vyřešíte všechny problémy ze vstupu (tedy volání obou načítacích funkcí vrací <tt>NULL</tt>).

    <p>Bylo zmíněno, že metoda <tt>Execute</tt> vytvoří <tt>thr+2</tt> vláken - dvě vlákna budou načítat 
      vstup voláním předaných ukazatelů na funkce. Fakticky ale stačí vytvořit pouze <tt>threads + 1</tt> 
      nových vláken a využít i vlákna. ze kterého byla volaná <tt>Execute</tt>.</p>

   <p>Metoda <tt>Execute</tt> skončí v okamžiku, kdy byly vyřešené všechny zadané vstupní problémy a další 
     nové problémy nejsou k dispozici (volání jak <tt>arbFn</tt>, tak <tt>xchgFn</tt> vrací <tt>NULL</tt>). Po 
     zaniknutí Vámi vytvořených pracovních vláken metoda <tt>Execute</tt> vrátí řízení volanému. Neukončujte 
     celý program (nevolejte <tt>exit</tt> a podobné funkce), pokud ukončíte celý program, budete hodnoceni 0 body.</p></dd>

 <dt><tt>ArbitrageSeq(arb)</tt></dt><dd> - metoda vypočte sekvenčně jeden zadaný problém typu 
    <tt>CArbitrage</tt> (parametr). Testovací prostředí nejprve zkouší sekvenční řešení, abyste případně 
    snáze odhalili chyby v implementaci algoritmu.</dd>

 <dt><tt>ExchangeSeq(xchg)</tt></dt><dd> - metoda vypočte sekvenčně jeden zadaný problém typu 
    <tt>CExchange</tt> (parametr). Testovací prostředí nejprve zkouší sekvenční řešení, abyste případně 
    snáze odhalili chyby v implementaci algoritmu.</dd>
</dl>

<p>Třída <tt>CArbitrage</tt> je deklarovaná a implementovaná v testovacím prostředí. 
Pro testování Vaší implementace je dispozici v bloku podmíněného překladu (ponechte jej tak). 
Význam složek je následující:</p>

<dl>
 <dt><tt>m_ProblemID</tt></dt><dd>jednoznačný identifikátor zadaného problému. Tento identifikátor 
   předejte jako parametr funkci, kterou oznámíte vyřešení této instance problému.</dd>

 <dt><tt>m_Rates</tt></dt><dd>C++ řetězec se seznamem převáděných měn a jejich kurzů. Řetězec 
   je čárkami oddělený seznam dvojic měn (měna je vždy zadána zkratkou z velkých písmen) 
   a kurzu (desetinné číslo). Přesný popis je dán EBNF níže, intuitivně je formát zřejmý z ukázek.</dd>

 <dt><tt>m_Arbitrage</tt></dt><dd>příznak, který vyplníte na základě Vašeho výpočtu. Bude nastaven na 
  <tt>true</tt>, pokud naleznete arbitrage.</dd>

 <dt><tt>m_Currency</tt></dt><dd>tuto složku vyplňujte pouze pokud narazíte na arbitrage. Pak bude obsahovat 
   posloupnost názvů měn jejichž konverzí lze dosáhnout arbitrage. Tedy např. pro příklad z ukázky (cyklus
   CZK -&gt; USD -&gt; EUR  -&gt; GBP -&gt; CZK) bude složka vyplněna 5 řetězci v tomto pořadí: "CZK", "USD", "EUR", "GBP" 
   a "CZK".  Pokud existuje více možností výběru měn pro arbitrage, můžete do výsledku uložit libovolnou 
   takovou sekvenci.</dd>

 <dt><tt>m_Rate</tt></dt><dd>složku vyplňujte pouze pokud nastane arbitrage. Bude mít hodnotu kurzu, 
   kterého se dosáhne cyklickou výměnou měn podle <tt>m_Currency</tt>. Protože se má jednat o arbitrage,
   musí být kurz větší než 1.0 (vzhledem k pravidlům zaokrouhlení dokonce větší-roven 1.0001).</dd>
</dl>

<p>Třída <tt>CExchange</tt> je deklarovaná a implementovaná v testovacím prostředí. 
Pro testování Vaší implementace je dispozici v bloku podmíněného překladu (ponechte jej tak). 
Význam složek je následující:</p>

<dl>
 <dt><tt>m_ProblemID</tt></dt><dd>jednoznačný identifikátor zadaného problému. Tento identifikátor 
   předejte jako parametr funkci, kterou oznámíte vyřešení této instance problému.</dd>
   
 <dt><tt>m_From</tt></dt><dd>jméno měny, ze které chceme převádět.</dd>
  
 <dt><tt>m_To</tt></dt><dd>jméno měny, na kterou chceme převádět.</dd>

 <dt><tt>m_Banks</tt></dt><dd>seznam kurzovních lístků bank, které mohou převod realizovat. Pro každou 
   banku obsahuje řetězec s formátem, který odpovídá formátu ze zadání problémů <tt>CArbitrage</tt>.</dd>

 <dt><tt>m_Result</tt></dt><dd>příznak, zda lze požadovanou směnu vůbec realizovat (tj. zda 
   v seznamu existuje banka, která umožní postupnými konverzemi dojít od měny <tt>m_From</tt> ke 
   měně <tt>m_To</tt>. Pokud lze konverzi uskutečnit, nastavte příznak hodnotu <tt>true</tt>.</dd>

 <dt><tt>m_BankIdx</tt></dt><dd>pokud lze směnu realizovat, vyplňte tuto složku na pořadové číslo 
   banky, kde lze dosáhnout nejlepší kurz. Indexy počítáme od 0.</dd>

 <dt><tt>m_Currency</tt></dt><dd>pokud lze směnu realizovat, vyplňte tuto složku na posloupnost 
   názvů měn, kterými se lze dostat k nejlepšímu směnnému kurzu (v bance <tt>m_BankIdx</tt>). První 
   hodnota v poli musí být shodná s <tt>m_From</tt>, poslední s <tt>m_To</tt>.</dd>

 <dt><tt>m_Rate</tt></dt><dd>pokud lze směnu realizovat, nastavte tuto složku na hodnotu nejlepšího 
   směnného kurzu (musí odpovídat sekvenci konverzí podle <tt>m_Currency</tt> v bance <tt>m_BankIdx</tt>).
   Vypočtený kurz zaokrouhlete podle pravidel (zaokrouhlení dolů na 4 desetinná místa).</dd>
</dl>

<hr>

<p>Odevzdávejte zdrojový kód s implementací požadované třídy s požadovanými 
metodami. Můžete samozřejmě přidat i další podpůrné třídy a funkce.
Do Vaší implementace nevkládejte funkci <tt>main</tt> ani direktivy pro 
vkládání hlavičkových souborů. Funkci <tt>main</tt> a hlavičkové soubory 
lze ponechat pouze v případě, že jsou zabalené v bloku podmíněného 
překladu.</p>

<p>Využijte přiložený ukázkový soubor. Celá implementace patří do souboru 
<tt>solution.cpp</tt>, dodaný soubor je pouze mustr. Pokud zachováte bloky 
podmíněného překladu, můžete soubor <tt>solution.cpp</tt> odevzdávat jako 
řešení úlohy.</p>

<p>Při řešení lze využít C++11 API pro práci s vlákny (viz vložené hlavičkové 
soubory). Dostupný kompilátor však nezvládá C++11 ideálně. Pokud při použití C++11 
konstrukcí či API narazíte na chybu/nedokonalost kompilátoru, budete muset svůj 
program přepsat tak, abyste tuto chybu či nedokonalost obešli. Použitý kompilátor
je g++ verze 4.7.</p>

<hr>

<b>Nápověda:</b><br>

<ul>
 <li>Nejprve implementujte sekvenční funkce řešení problémů arbitrage/převodů měn. 
  Správnost implementace lze ověřit lokálně pomocí infrastruktury v přiloženém archivu. 
  Až budete mít funkce lokálně otestované,  můžete je zkusit odevzdat na Progtest 
  (pro tento pokus nechte metodu <tt>Execute</tt> s prázdným tělem). Takové řešení 
  samozřejmě nedostane žádné body, ale uvidíte, zda správně projde sekvenčními testy.</li>

 <li>Abyste zapojili co nejvíce jader, zpracovávejte několik problémů najednou. 
   Vyzvedněte je pomocí opakovaného volání <tt>arbFn/xchgFn</tt> a okamžitě po
   analýze oznamte dokončení pomocí <tt>complFn</tt>. Není potřeba dodržovat
   pořadí při oznamování. Pokud budete najednou zpracovávat pouze jeden problém, 
   nejspíše zaměstnáte pouze jedno vlákno a ostatní vlákna budou čekat 
   bez užitku.</li>

 <li>Instance <tt>CConsultant</tt> je vytvářená opakovaně, pro různé vstupy.
   Nespoléhejte se na inicializaci globálních proměnných - při druhém a dalším 
   zavolání budou mít globální proměnné hodnotu jinou. Je rozumné případné globální 
   proměnné vždy inicializovat na začátku metody <tt>Execute</tt>. Ještě
   lepší je nepoužívat globální proměnné vůbec.</li>

 <li>Nepoužívejte mutexy a podmíněné proměnné inicializované pomocí
   <tt>PTHREAD_MUTEX_INITIALIZER</tt>, důvod je stejný jako v minulém odstavci. 
   Použijte raději <tt>pthread_mutex_init()</tt>.</li>

 <li>Testovací prostředí samo o sobě nevytváří žádná vlákna, tedy metoda
   <tt>Execute</tt> sama o sobě nemusí být reentrantní (může používat 
   globální proměnné, s omezením výše).</li>

 <li>Instance tříd CArbitrage / CExchange alokovalo testovací prostředí. 
     Testovací prostředí se také postará o jejich uvolnění (po převzetí funkcí
     <tt>comlpFn</tt>). Jejich uvolnění tedy není Vaší starostí. Váš program je ale 
     zodpovědný za uvolnění všech ostatních prostředků, které si alokoval.</li>

 <li>Problémy musíte načítat, zpracovávat a odevzdávat průběžně. Postup, kdy
   si všechny problémy načtete do paměťových struktur a teprve pak je začnete 
   zpracovávat, nebude fungovat. Takové řešení skončí deadlockem v prvním testu 
   s více vlákny. Musíte zároveň obsluhovat požadavky typu arbitrage i exchange. Řešení, 
   které se bude snažit nejprve vyřešit všechny problémy typu arbitrage a pak začne 
   obsluhovat problémy exchange, skončí taktéž deadlockem.</li>

 <li>Volání <tt>complFn</tt> je reentrantní, není potřeba je serializovat
   (obalovat mutexy). Každý vyřešený problém odevzdávejte právě 1x. Rozumné 
   je volat funkci <tt>complFn</tt> přímo z pracovního vlákna, které pro daný problém
   dokončilo analýzu.</li>

 <li>Neukončujte metodu <tt>Execute</tt> pomocí <tt>exit</tt>,
   <tt>pthread_exit</tt> a podobných funkcí. Pokud se funkce <tt>Execute</tt> 
   nevrátí do volajícího, bude Vaše implementace vyhodnocena jako nesprávná.</li>

 <li>Využijte přiložená vzorová data. V archivu jednak naleznete ukázku
   volání rozhraní (práce s ukazateli na funkce) a dále několik testovacích
   vstupů a odpovídajících výsledků.</li>

 <li>Nebojte se ukazatelů na funkce. Předaný parametr, např. <tt>arbFn</tt> použijte 
   při volání jako každou jinou funkci:
   <pre>    class CConsultant 
    {
      ...
      CArbitrage   * (* m_ArbFn ) ( void );

                        CConsultant ( CArbitrage * (* arbFn)( void ), .... )
                         : m_ArbFn ( arbFn ), ....

      void              foobar ( ... )
      {
       ...
       CArbitrage * x = m_ArbFn ();
       ...
      } 
   </pre>

   Pokud chcete volat funkci zprostředkovanou ukazatelem <tt>arbFn</tt> z jiné 
   třídy/funkce, musíte si ukazatel předat podobně jako každou jinou proměnnou:

   <pre>    void foo ( void )
     {
       // nefunguje, funkce s takovym jmenem (asi) v testovacim prostredi
       // neexistuje 
       x = arbFn ( ); 
       x = m_ArbFn ();
     }
    void bar ( const CArbitrage * (* anotherArbFnPointer) ( void ) )
     {
       x = anotherArbFnPointer (); // ok
     }
    ....
    void CConsultant::foobar ( ... )
     {
       ...
       bar ( m_ArbFn );
       ...
     } 
   </pre></li>
 <li>V testovacím prostředí je k dispozici STL. Myslete ale na to, že ten samý STL 
     kontejner nelze najednou zpřístupnit z více vláken. Více si o omezeních přečtěte např. 
     na <a href="http://en.cppreference.com/w/cpp/container">C++ reference - thread safety.</a></li>

 <li>Testovací prostředí je omezené velikostí paměti. Není uplatňován žádný explicitní limit, ale VM, 
   ve které testy běží, je omezena 1 GiB celkové dostupné RAM. Úloha může být dost paměťově náročná, 
   zejména pokud se rozhodnete pro jemné členění úlohy na jednotlivá vlákna. Pokud se rozhodnete pro 
   takové jemné rozčlenění úlohy, možná budete muset přidat synchronizaci běhu vláken tak, aby celková 
   potřebná paměť v žádný okamžik nepřesáhla rozumný limit. Pro běh máte garantováno, že Váš program 
   má k dispozici nejméně 500 MiB pro Vaše data (data segment + stack + heap). Pro zvídavé - zbytek do 
   1GiB je zabraný běžícím OS, dalšími procesy, zásobníky Vašich vláken a nějakou rezervou.</li>

 <li>Při řešení problému Exchange provádíme všechny převody pouze v rámci jedné banky. Toto chování 
  je vidět i v ukázkovém příkladu. Pokud bychom převáděli i napříč bankami, nejspíše bychom mohli dosáhnout 
  lepších kurzů, ale převody do jiné banky  trvají dlouho a změnily by se kurzy.</li>

 <li>Při řešení problému typu Exchange by se mohlo stát, že vložený kurzovní lístek nějaké banky 
  umožňuje i arbitrage. Data zadávaná testovacím prostředí jsou však taková, že arbitrage v datech pro převod
  nikdy nenastane (nemusíte jej kontrolovat).</li>

 <li>Pro interní výpočet použijte desetinná čísla typu <tt>double</tt>. Jejich přesnost je pro 
  zadanou úlohu dostačující. Podle zvoleného algoritmu si však budete muset dávat pozor na drobné 
  nepřesnosti při porovnávání (vzpomeňte si na PA1). Není dobrý nápad použít pro výpočet celá čísla 
  (např. s posunutou řádovou čárkou), výsledky jsou velmi nepřesné (např. pokud se při problému 
  arbitrage pohybujete v okolí 1.0). 

 </li><li>Pokud se rozhodnete pro všechny bonusy, je potřeba velmi pečlivě nastavovat granularitu řešeného 
  problému. Pokud řešený problém rozdělíte na příliš mnoho drobných podproblémů, začne se příliš mnoho 
  uplatňovat režie. Dále, pokud máte najednou rozpracováno příliš mnoho problémů (a každý je rozdělen 
  na velké množství podproblémů), začne se výpočet dále zpomalovat (mj. se začnou hůře využívat cache CPU).
  Aby se tomu zabránilo, řídí referenční řešení počet najednou rozpracovaných úloh (navíc dynamicky 
  podle velikosti rozpracované úlohy).</li>

 <li>Formát kurzovních lístků je intuitivně jasný. Následující EBNF jej popisuje exaktně:
 <pre>   rates  ::=  ws rate { ws ',' ws rate } ws
   rate   ::=  cur ws '-&gt;' ws cur ws ':' ws val
   cur    ::=  letter { letter }
   val    ::=  num ['.' [num] ] [ 'e'  [ '+' | '-' ] num ]  |
               '.' num [ 'e'  [ '+' | '-' ] num ] 
   num    ::=  digit { digit }
   digit  ::=  '0' | '1' | '2' | ... | '9'
   letter ::= 'A' | 'B' | 'C' | ... | 'Z' | 'a' | 'b' | ... | 'z'
   ws     ::= { ' ' | '\t' | '\r' | '\n' }
 <pre></pre></pre></li>
</ul>

<hr>

<b>Co znamenají jednotlivé testy:</b><br>
<dl>
 <dt><b>Test algoritmu (sekvencni)</b></dt><dd>Testovací prostředí opakovaně
   volá metody <tt>ArbitrageSeq/ExchangeSeq</tt> pro různé vstupy a kontroluje 
   vypočtené výsledky. Slouží pro otestování implementace Vašeho algoritmu. 
   Není vytvářena instance <tt>CConsultant</tt> a není volaná metoda <tt>Execute</tt>. 
   Na tomto testu můžete ověřit, zda Vaše implementace algoritmu je dostatečně rychlá.
   Testují se jednak data z dodané ukázky a dále i náhodně generované problémy.</dd>

 <dt><b>Základní test/test několika/test mnoha thready</b></dt><dd>Testovací
   prostředí volá funkci <tt>Execute</tt> pro různý počet vláken.

 </dd><dt><b>Test zahlcení</b></dt><dd>Testovací prostředí generuje velké množství 
   požadavků a kontroluje, zda si s tím Vaše implementace poradí. Pokud nebudete 
   rozumně řídit počet rozpracovaných požadavků, překročíte paměťový limit.

 </dd><dt><b>Test zrychleni vypoctu</b></dt><dd>Testovací prostředí spouští Vaši
   implementaci pro ta samá vstupní data s různým počtem vláken. Měří se čas běhu  
   (wall i CPU). S rostoucím počtem vláken by měl wall time klesat, CPU time 
   mírně růst (vlákna mají možnost běžet na dalších CPU). Pokud wall time    
   neklesne, nebo klesne málo (např. pro 2 vlákna by měl ideálně klesnout na 
   0.5, existuje určitá rezerva), test není splněn.</dd>

 <dt><b>Busy waiting - pomale pozadavky</b></dt><dd>Do volání
   <tt>arbFn/xchgFn</tt> testovací prostředí vkládá uspávání vlákna 
   (např. na 100 ms). Výpočetní vlákna tím nemají práci. Pokud výpočetní vlákna 
   nejsou synchronizovaná blokujícím způsobem, výrazně vzroste CPU time a test
   selže.</dd>      

 <dt><b>Busy waiting - pomale notifikace</b></dt><dd>Do volání <tt>complFn</tt>
   je vložena pauza. Pokud jsou špatně blokována vlákna načítající vstup, výrazně 
   vzroste CPU time. (Tento scénář je zde méně pravděpodobný.) Dále tímto testem
   neprojdete, pokud zbytečně serializujete volání <tt>complFn</tt>.</dd>

 <dt><b>Busy waiting - complex</b></dt><dt></dt><dd>Je kombinací dvou posledně
   jmenovaných testů.</dd>

<dt><b>Test rozlozeni zateze 1</b></dt><dd>Testovací prostředí zkouší výpočet pouze 
   pro jeden druh problémů (arb/xchg). Výpočet by měl být rozdělen mezi všechna 
   dostupná vlákna, vlákna by neměla být určena pro řešení problému pouze jednoho typu.
   Pokud není výpočet dostatečně zrychlen, test selže. Test není povinný, ale 
   jeho nezvládnutí znamená citelný bodový postih.</dd> 

<dt><b>Test rozlozeni zateze 2</b></dt><dd>Testovací prostředí zkouší, zda 
   se do řešení jednoho problému typu exchange dokáže zapojit více dostupných vláken. Pokud chcete 
   v tomto testu uspět, musíte Váš program navrhnout tak, aby bylo možné využít 
   více vláken i při analýze jedné instance problému <tt>CExchange</tt>. Jedná se o 
   test bonusový.</dd>

<dt><b>Test rozlozeni zateze 3</b></dt><dd>Testovací prostředí zkouší, zda 
   se do řešení jednoho problému typu arbitrage/exchange s jednou bankou dokáže 
   zapojit více dostupných vláken. Pokud chcete v tomto testu uspět, musíte Váš 
   program navrhnout tak, aby bylo možné využít více vláken i při analýze jedné 
   instance problému. Jedná se o test bonusový.</dd>
   
</dl>

<hr>

<b>Jak to vyřešit - pozor, SPOILER</b>
<p>Pokud se nechcete obrat o dobrý pocit, že jste úlohu vyřešili zcela sami, 
nečtěte dále.</p>
<ul>
 <li>Oba problémy jsou řešitelné pomocí stejného principu - převodu na grafový problém.</li>

 <li>Pro tento grafový problém existuje řada algoritmů, které jej dokáží vyřešit. Některé 
  algoritmy ale nejdou použít, protože vstupní data nesplňují potřebné podmínky (například 
  může vadit, že kurz může být větší než 1).</li>

 <li>Řešení problémů lze zvládnout v čase <tt>O(n^3)</tt>, resp. <tt>O( b n^3 )</tt> (<tt>b</tt> 
  je počet bank v problému <tt>CExchange</tt>). Testovací prostředí měří rychlost Vaší 
  sekvenční implementace pro různé velikosti vstupů, podle změřeného času pak upravuje 
  velikost problémů v paralelní části.<p></p>

 </li><li>Rozdílná časová složitost problémů byla zvolena úmyslně, abyste byli nuceni dynamicky
  rozdělovat požadavky na výpočetní vlákna.</li>

 <li>Vzhledem k heterogennímu charakteru vstupních dat se hodí objektový návrh 
  s polymorfismem.</li>
</ul>

<b>Další nápověda - SUPERSPOILER</b><br>

<p>Podle potřeby v průběhu řešení úlohy zveřejníme další nápovědy pro 
tápající studenty.</p>

</td>
       </tr>


       <tr>
        <td class="ltbCell" colspan="2" align="left"><b>Vzorová data:</b></td>
        <td class="rtbCell" align="center"><div class="but1 w120"><div class="but2"><a class="butLink" href="https://progtest.fit.cvut.cz/index.php?X=TaskS&amp;Cou=170&amp;Tgr=1062&amp;Tsk=1303">Download</a></div></div></td>
       </tr>






       <tr>
 
        <td class="ltbCell" align="left" valign="top"><b>Odevzdat:</b></td>
        <td class="tbCell" align="left" valign="top"><input class="std" name="FILE" type="file"></td>
        <td class="rtbCell" valign="top"><div class="w120 outButton"><input name="S" value="Odevzdat" class="updButton" type="submit"></div></td>
 
       </tr>








      </tbody></table>
     </div>
    </div>


 <br>
 <div class="topLayout">
  <div class="outBox">
   <table id="reftable" border="0" cellpadding="2" cellspacing="0" width="100%">
   <tbody><tr>
    <td class="ltbSepCell" align="left"><input name="SHOW_REF" onchange="showRefSolution()" type="checkbox">&nbsp;<b>Referenční řešení</b></td>
    <td class="rtbSepCell" align="right">&nbsp;</td>
   </tr>
   <tr style="display: none;">
    <td class="lrtbCell" colspan="2" align="left"><ul><li><b>Hodnotitel: automat</b><ul><li>Program zkompilován</li><li>Test 'Test algoritmu arbitrage (sekvencni)': Úspěch<ul><li>Dosaženo: 100.00 %, požadováno: 100.00 %</li><li>Celková doba běhu: 0.007 s (limit: 3.000 s)</li><li>Úspěch v závazném testu, hodnocení: 100.00 %</li></ul></li>
<li>Test 'Test algoritmu exchange (sekvencni)': Úspěch<ul><li>Dosaženo: 100.00 %, požadováno: 100.00 %</li><li>Celková doba běhu: 0.005 s (limit: 2.993 s)</li><li>Úspěch v závazném testu, hodnocení: 100.00 %</li></ul></li>
<li>Test 'Zakladni test (1 thread)': Úspěch<ul><li>Dosaženo: 100.00 %, požadováno: 80.00 %</li><li>Celková doba běhu: 1.232 s (limit: 20.000 s)</li><li>Úspěch v závazném testu, hodnocení: 100.00 %</li></ul></li>
<li>Test 'Test nekolika thready': Úspěch<ul><li>Dosaženo: 100.00 %, požadováno: 80.00 %</li><li>Celková doba běhu: 0.700 s (limit: 18.768 s)</li><li>CPU time: 1.906 s (limit: 18.720 s)</li><li>Úspěch v závazném testu, hodnocení: 100.00 %</li></ul></li>
<li>Test 'Test mnoha thready': Úspěch<ul><li>Dosaženo: 100.00 %, požadováno: 80.00 %</li><li>Celková doba běhu: 0.634 s (limit: 18.068 s)</li><li>CPU time: 3.755 s (limit: 16.814 s)</li><li>Úspěch v závazném testu, hodnocení: 100.00 %</li></ul></li>
<li>Test 'Test zahlceni': Úspěch<ul><li>Dosaženo: 100.00 %, požadováno: 80.00 %</li><li>Celková doba běhu: 1.964 s (limit: 17.434 s)</li><li>Úspěch v závazném testu, hodnocení: 100.00 %</li></ul></li>
<li>Test 'Test zrychleni vypoctu': Úspěch<ul><li>Dosaženo: 100.00 %, požadováno: 50.00 %</li><li>Celková doba běhu: 2.213 s (limit: 15.470 s)</li><li>CPU time: 4.596 s (limit: 11.092 s)</li><li>Úspěch v závazném testu, hodnocení: 100.00 %</li></ul></li>
<li>Test 'Busy waiting test (pomale pozadavky)': Úspěch<ul><li>Dosaženo: 100.00 %, požadováno: 50.00 %</li><li>Celková doba běhu: 1.518 s (limit: 10.000 s)</li><li>Úspěch v nepovinném testu, hodnocení: 100.00 %</li></ul></li>
<li>Test 'Busy waiting test (pomale notifikace)': Úspěch<ul><li>Dosaženo: 100.00 %, požadováno: 50.00 %</li><li>Celková doba běhu: 1.214 s (limit: 8.482 s)</li><li>Úspěch v nepovinném testu, hodnocení: 100.00 %</li></ul></li>
<li>Test 'Busy waiting test (complex)': Úspěch<ul><li>Dosaženo: 100.00 %, požadováno: 50.00 %</li><li>Celková doba běhu: 1.716 s (limit: 7.268 s)</li><li>Úspěch v nepovinném testu, hodnocení: 100.00 %</li></ul></li>
<li>Test 'Test rozlozeni zateze 1': Úspěch<ul><li>Dosaženo: 100.00 %, požadováno: 75.00 %</li><li>Celková doba běhu: 0.069 s (limit: 5.552 s)</li><li>CPU time: 0.179 s (limit: 9.886 s)</li><li>Úspěch v nepovinném testu, hodnocení: 100.00 %</li></ul></li>
<li>Test 'Test rozlozeni zateze 2': Úspěch<ul><li>Dosaženo: 100.00 %, požadováno: 100.00 %</li><li>Celková doba běhu: 0.374 s (limit: 5.000 s)</li><li>CPU time: 0.951 s (limit: 5.000 s)</li><li>Úspěch v bonusovém testu, hodnocení: 115.00 %</li></ul></li>
<li>Test 'Test rozlozeni zateze 3': Úspěch<ul><li>Dosaženo: 100.00 %, požadováno: 100.00 %</li><li>Celková doba běhu: 0.404 s (limit: 4.626 s)</li><li>CPU time: 1.271 s (limit: 4.049 s)</li><li>Úspěch v bonusovém testu, hodnocení: 115.00 %</li></ul></li>
<li>Celkové hodnocení: 132.25 % (= 1.00 * 1.00 * 1.00 * 1.00 * 1.00 * 1.00 * 1.00 * 1.00 * 1.00 * 1.00 * 1.00 * 1.15 * 1.15)</li></ul></li><li>Celkové procentní hodnocení: 132.25 %</li><li>Bonus za včasné odevzdání: 3.00</li><li>Celkem bodů: 1.32 * ( 30.00 + 3.00 ) = 43.64</li></ul></td>
   </tr>
    <tr style="display: none;">
  <td class="ltbCell" align="left"><b>SW metriky:</b></td>
  <td class="rtbCell" colspan="2" align="left">
   <table border="0" cellpadding="2">
    <tbody><tr>
     <td>&nbsp;</td>
     <td class="ac">Celkem</td>
     <td class="ac">Průměr</td>
     <td class="ac">Maximum</td>
     <td>Jméno funkce</td>
    </tr>
    <tr>
     <td>Funkce:</td>
     <td class="ar"><b>35</b></td>
     <td class="ar">--</td>
     <td class="ar">--</td>
     <td>--</td>
    </tr>
    <tr>
     <td>Řádek kódu:</td>
     <td class="ar"><b>548</b></td>
     <td class="ar"><span class="textOk">15.65 ± 6.34</span></td>
     <td class="ar"><span class="textOk">31</span></td>
     <td><tt>CComputeWrapper(CArbitrage &amp;&amp;, shared_ptr&lt;CJob&gt; (*)(CProblem &amp;))</tt></td>
    </tr>
    <tr>
     <td>Cyklomatická složitost:</td>
     <td class="ar"><b>297</b></td>
     <td class="ar"><span class="textOk">8.48 ± 4.62</span></td>
     <td class="ar"><span class="textOk">18</span></td>
     <td><tt>CComputeWrapper(CArbitrage &amp;&amp;, shared_ptr&lt;CJob&gt; (*)(CProblem &amp;))</tt></td>
    </tr>
   </tbody></table>
  </td>
 </tr>
   </tbody></table>
  </div>
 </div>





  </center>
 </form>








<script language="javascript" type="text/javascript">
<!--

var deadLine = new Date ( 1460325599 * 1000 );

function CBpressed ( num )
 {
   var pre, cb;

   cb = MM_findObj ( "cb_" + num );
   pre = MM_findObj ( "pre_" + num );
   if ( cb != null && pre != null )
    {
      pre . style . display = cb . checked ? "block" : "none";
    }
 }

function unlockAdvice ( url )
 {
   if ( confirm ( 'Máte k dispozici pouze omezený počet nápověd. Navíc, použití nápovědy může snížit bodové hodnocení. Opravdu chcete zpřístupnit tuto nápovědu?' ) )
    this . location = url;
 }

function setCountdown ( )
 {
   var d = new Date ();
   var x = ( deadLine . getTime () - d . getTime () );
   var tgt = document . getElementById ( "countdown" );

   if ( x > 0 )
    {
      var s = Math . floor ( x / 1000 );
      var ms = (x % 1000) + "";

      while ( ms . length  < 3 ) ms = "0" + ms;

      tgt . innerHTML = s + "." + ms + " sec";

      window . setTimeout ( setCountdown, 117 );
    }
   else
    {
      tgt . innerHTML = '&nbsp;';
    }
 }

function showRefSolution ( )
 {
   var t = document . getElementById ( "reftable" );
   var x = document . getElementsByName ( "SHOW_REF" )[0];

   if ( ! x ) return;
   var r1 = t . rows[1], r2 = t . rows[2];

   if ( x . checked )
    {
      r1 . style . display = "";
      if ( r2 ) r2 . style . display = "";
    }
   else
    {
      r1 . style . display = "none";
      if ( r2 ) r2 . style . display = "none";
    }
 }


setCountdown ();
showRefSolution ();

// -->
</script>





 


</body></html>
<!-- Template run time: 0.023172855377197 sec -->